//#CM566267
//$Id: StorageHostSendFinder.java,v 1.2 2006/12/07 08:56:16 suresh Exp $
package jp.co.daifuku.wms.storage.dbhandler ;

//#CM566268
/*
 * Copyright 2000-2003 DAIFUKU Co.,Ltd. All Rights Reserved.
 *
 * This software is the proprietary information of DAIFUKU Co.,Ltd.
 * Use is subject to license terms.
 */
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Vector;

import jp.co.daifuku.common.ReadWriteException;
import jp.co.daifuku.common.RmiMsgLogClient;
import jp.co.daifuku.common.TraceHandler;
import jp.co.daifuku.common.text.DBFormat;
import jp.co.daifuku.common.text.SimpleFormat;
import jp.co.daifuku.common.text.StringUtil;
import jp.co.daifuku.wms.base.common.DEBUG;
import jp.co.daifuku.wms.base.common.Entity;
import jp.co.daifuku.wms.base.common.SearchKey;
import jp.co.daifuku.wms.base.entity.HostSend;
import jp.co.daifuku.wms.base.dbhandler.HostSendFinder;
import jp.co.daifuku.wms.storage.dbhandler.StorageHostSendSearchKey;

//#CM566269
/**
 * The class to retrieve the HostSend table of the data base and to do the mapping to HostSendView. <BR>
 * Use this class when you have a look at display of the retrieval result on the screen. <BR>
 * <BR>
 * <TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0">
 * <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor"><TD>Date</TD><TD>Name</TD><TD>Comment</TD></TR>
 * <TR><TD>2003/03/11</TD><TD>kaminishizono</TD><TD>created this class</TD></TR>
 * </TABLE>
 * <BR>
 * @version $Revision: 1.2 $, $Date: 2006/12/07 08:56:16 $
 * @author  $Author: suresh $
 */
public class StorageHostSendFinder extends HostSendFinder
{
	//#CM566270
	// Class filelds -----------------------------------------------
	//#CM566271
	/**
	 * Variable which maintains whether next method can be called. 
	 */
	protected boolean isNextFlag = true;

	//#CM566272
	// Class method --------------------------------------------------
	//#CM566273
	/**
	 * Return the version of this class. 
	 * @return Version and date
	 */
	public static String getVersion()
	{
		return ("$Revision: 1.2 $,$Date: 2006/12/07 08:56:16 $") ;
	}

	//#CM566274
	// Constructors --------------------------------------------------
	//#CM566275
	/**
	 * Generate the instance specifying <code>Connection</code> for the database connection. 
	 * @param conn Connection Connection to database
	 */
	public StorageHostSendFinder(Connection conn)
	{
		super(conn);
	}

	//#CM566276
	// Public methods ------------------------------------------------
	
	//#CM566277
	/**
	 * Make the retrieval result of the data base an entity array and return it. 
	 * @param count int Retrieval qty
	 * @return Entity array which stores retrieval result
 	 * @throws ReadWriteException Notify the exception generated by the database connection as it is. 
	 */
	public Entity[] getEntityesStockMove(int count) throws ReadWriteException
	{
		Vector vec = new Vector();
		HostSend[] hostSend = null;

		try
		{
			//#CM566278
			// Count the qty read this time. 
			int readCount = 0;
			//#CM566279
			// Flag whether to close ResultSet. Close after reading the final line. 
			boolean endFlag = true;
			while (p_ResultSet.next())
			{
				HostSend vHostSend = new HostSend();

				vHostSend.setWorkDate(DBFormat.replace(p_ResultSet.getString("WORK_DATE")));
				vHostSend.setConsignorCode(DBFormat.replace(p_ResultSet.getString("CONSIGNOR_CODE")));
				vHostSend.setConsignorName(DBFormat.replace(p_ResultSet.getString("CONSIGNOR_NAME")));
				vHostSend.setItemCode(DBFormat.replace(p_ResultSet.getString("ITEM_CODE")));
				vHostSend.setItemName1(DBFormat.replace(p_ResultSet.getString("ITEM_NAME1")));
				vHostSend.setResultQty(p_ResultSet.getInt("RESULT_QTY"));
				vHostSend.setEnteringQty(p_ResultSet.getInt("ENTERING_QTY"));
				vHostSend.setLocationNo(DBFormat.replace(p_ResultSet.getString("LOCATION_NO")));
				vHostSend.setResultLocationNo(DBFormat.replace(p_ResultSet.getString("RESULT_LOCATION_NO")));
				vHostSend.setResultUseByDate(DBFormat.replace(p_ResultSet.getString("RESULT_USE_BY_DATE")));

				vec.addElement(vHostSend);

				//#CM566280
				// It comes off when the specified number of cases is read. 
				readCount++;
				if (count <= readCount)
				{
					endFlag = false;
					break;
				}
			}
			//#CM566281
			// Close after reading the final line. 
			if (endFlag)
			{
				close();
			}
			hostSend = new HostSend[vec.size()];
			vec.copyInto(hostSend);
		}
		catch (SQLException e)
		{
			//#CM566282
			//6006002 = Database error occurred.{0}
			RmiMsgLogClient.write( new TraceHandler(6006002, e), "StorageHostSendFinder" ) ;
			throw (new ReadWriteException("6006002" + wDelim + "DnHostSend")) ;
		}
		return hostSend;
	}

	//#CM566283
	/**
	 * Retrieve HostSend, and acquire it. 
	 * @param key StorageHostSendSearchKey Key for retrieval
	 * @param sql String Sub-inquiry SQL sentence
	 * @return Number of retrieval results
	 * @throws ReadWriteException Notify the exception generated by the connection with the data base as it is. 
	 */
	public int search(StorageHostSendSearchKey key, String sql) throws ReadWriteException
	{
		close();
		isNextFlag = true;
		open();
		Object[]  fmtObj = new Object[5];
		Object[]  cntObj = new Object[5];
		int count = 0;
		ResultSet countret  = null ;
		
	 	try
	 	{
		
			String fmtCountSQL = "SELECT COUNT({0}) COUNT FROM DNHOSTSEND {1} {2} {3} {4} ";

			String fmtSQL = "SELECT DISTINCT {0} ";
			fmtSQL += "FROM DNHOSTSEND " + "{1} {2} {3} {4}";

			//#CM566284
			// 	Edit the acquisition condition. (For COUNT)
			//#CM566285
			// It is assumed all item acquisition. 
			cntObj[0] = " * " ;

			//#CM566286
			// Edit the acquisition condition. 
			if (key.getCollectCondition() != null)
			{
				fmtObj[0] = key.getCollectCondition() ;
				fmtObj[0] = fmtObj[0] + ", " + key.ReferenceJoinColumns() ;
			} else {
				//#CM566287
				// It is assumed all item acquisition in the acquisition condition at a specified doing. 
				fmtObj[0] = " * " ;
			}

			//#CM566288
			// Edit the joining table. 
			if(!StringUtil.isBlank(key.getJoinTable()))
			{
				if(StringUtil.isBlank(sql))
				{
					fmtObj[1] = ", " + key.getJoinTable();
					cntObj[1] = ", " + key.getJoinTable();
				}
				else
				{
					fmtObj[1] = ", ( " + sql + " ) " + key.getJoinTable();
					cntObj[1] = ", ( " + sql + " ) " + key.getJoinTable();
				}
			}

			//#CM566289
			// Edit the search condition. 
			if (key.getReferenceCondition() != null)
			{
				fmtObj[2] = "WHERE " + key.getReferenceCondition();
				cntObj[2] = "WHERE " + key.getReferenceCondition();
			}

			//#CM566290
			// Edit the joining condition. 
			if (key.ReferenceJoinWhere() != null)
			{
				if(StringUtil.isBlank(fmtObj[2].toString()))
				{
					fmtObj[2] = " WHERE " + key.ReferenceJoinWhere();
					cntObj[2] = " WHERE " + key.ReferenceJoinWhere();
				}
				else
				{
					fmtObj[2] = fmtObj[2] + " AND " + key.ReferenceJoinWhere();
					cntObj[2] = cntObj[2] + " AND " + key.ReferenceJoinWhere();
				}
			}

			//#CM566291
			// Edit the consolidating condition. 
			if (key.getGroupCondition() != null)
			{
				fmtObj[3] = " GROUP BY " + key.getGroupCondition();
				cntObj[3] = " GROUP BY " + key.getGroupCondition();
			}

			//#CM566292
			// Edit the order of reading. 
			if (key.getSortCondition() != null)
			{
				fmtObj[4] = " ORDER BY " + key.getSortCondition();
				cntObj[4] = " ORDER BY " + key.getSortCondition();
			}

			String sqlcountstring = SimpleFormat.format(fmtCountSQL, cntObj) ;
DEBUG.MSG("HANDLER", "StorageHostSend Finder COUNT SQL[" + sqlcountstring + "]") ;
			countret = p_Statement.executeQuery(sqlcountstring);
			while (countret.next())
			{
				count = countret.getInt("COUNT");
			}
			String sqlstring = SimpleFormat.format(fmtSQL, fmtObj) ;
DEBUG.MSG("HANDLER", "StorageHostSend Finder SQL[" + sqlstring + "]") ;
			p_ResultSet = p_Statement.executeQuery(sqlstring);
		}
		catch (SQLException e)
		{
			//#CM566293
			//6006002 = Database error occurred.{0}
			RmiMsgLogClient.write( new TraceHandler(6006002, e), "StorageHostSendFinder" ) ;
			throw (new ReadWriteException("6006002" + wDelim + "DnHostSend")) ;
		}
		return count;
	}

	//#CM566294
	/**
	 * Retrieve HostSend, and acquire it. 
	 * @param key StorageHostSendSearchKey Key for retrieval
	 * @return Number of retrieval results
	 * @throws ReadWriteException Notify the exception generated by the connection with the data base as it is. 
	 */
	public int search(StorageHostSendSearchKey key) throws ReadWriteException
	{
		close();
		isNextFlag = true;
		open();
		
		int count = super.search(key);
		
		return count;
	}

	//#CM566295
	/**
	 * Make SQL sentence which retrieves HostSend. 
	 * @param key Key for retrieval
	 * @return Made SQL sentence
	 * @throws ReadWriteException It is notified when the trouble occurs under the making condition of SQL sentence. 
	 */
	public String createFindSql(SearchKey key) throws ReadWriteException
	{
		Object[] fmtObj = new Object[4];

		String fmtSQL = "SELECT {0} ";
		fmtSQL += "FROM DNHOSTSEND " + "{1} {2} {3}";

		//#CM566296
		// Edit the acquisition condition. 
		if (key.getCollectCondition() != null)
		{
			fmtObj[0] = key.getCollectCondition() ;
		} else {
			//#CM566297
			// It is assumed all item acquisition in the acquisition condition at a specified doing. 
			fmtObj[0] = " * " ;
		}

		//#CM566298
		// Edit the search condition. 			
		if (key.getReferenceCondition() != null)
		{
			fmtObj[1] = " WHERE " + key.getReferenceCondition();
		}

		//#CM566299
		// Edit the consolidating condition. 			
		if (key.getGroupCondition() != null)
		{
			fmtObj[2] = " GROUP BY " + key.getGroupCondition();
		}
			
		//#CM566300
		// Edit the order of reading. 
		if (key.getSortCondition() != null)
		{
			fmtObj[3] = " ORDER BY " + key.getSortCondition();
		}
		String sqlstring = SimpleFormat.format(fmtSQL, fmtObj);

		return sqlstring;
	}

	//#CM566301
	/**
	 * Return whether the next method can be executed. 
	 * @return Result of check (Executable : true Non executable : false) 
	 */
	public boolean isNext()
	{
		return isNextFlag;
	}

	//#CM566302
	/**
	 * Close the statement. 
	 * @throws ReadWriteException Notify when abnormality occurs by the connection with the database. 
	 */
	public void close() throws ReadWriteException
	{
		try
		{
			//#CM566303
			// The actions so called Close or Not readable makes isNextFlag False.
			isNextFlag = false;
			if (p_ResultSet != null) 
			{
				p_ResultSet.close();
				p_ResultSet = null;
			}
			if (p_Statement != null) 
			{
				p_Statement.close();
				p_Statement = null;
			}
		}
		catch (Exception e)
		{
			//#CM566304
			//6006002 = Database error occurred.{0}
			RmiMsgLogClient.write( new TraceHandler(6006002, e), this.getClass().getName() ) ;
			//#CM566305
			//Here, throw ReadWriteException with the error message. 
			throw (new ReadWriteException("6006002" + wDelim + "DnHostSend"));
		}
	}

	//#CM566306
	// Package methods -----------------------------------------------

	//#CM566307
	// Protected methods ---------------------------------------------

	//#CM566308
	// Private methods -----------------------------------------------

}
//#CM566309
//end of class

