// $Id: AbstractDBReportFinder.java,v 1.2 2006/11/15 04:25:36 kamala Exp $
package jp.co.daifuku.wms.base.dbhandler;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Vector;

import jp.co.daifuku.common.ReadWriteException;
import jp.co.daifuku.common.RmiMsgLogClient;
import jp.co.daifuku.common.TraceHandler;
import jp.co.daifuku.common.text.SimpleFormat;
import jp.co.daifuku.wms.base.common.DEBUG;
import jp.co.daifuku.wms.base.common.Entity;
import jp.co.daifuku.wms.base.common.SearchKey;
import jp.co.daifuku.wms.base.entity.AbstractEntity;


//#CM708348
/**
 * < CODE>AbstructDBReportFinder</CODE > class is a super-class to operate the data base (table). 
 * <BR>
 *
 * <hr><table border="1" cellpadding="3" cellspacing="0" width="90%">
 * <caption><font size="+1"><b>Update History</b></font></caption>
 * <tbody><tr bgcolor="#CCCCFF" class="TableHeadingColor" align="center">
 * <td><b>Date</b></td><td><b>Y.Kato</b></td><td><b>New making</b></td></tr>
 *
 * </tbody></table><hr>
 *
 * @version $Revision, $Date: 2006/11/15 04:25:36 $
 * @author  C.Kaminishizono
 * @author  Last commit: $Author: kamala $
 */
public abstract class AbstractDBReportFinder
			implements DatabaseReportFinder
{
	private static final int MAX_RESULT = 5000 ;

	//#CM708349
	//------------------------------------------------------------
	//#CM708350
	// properties (prefix 'p_')
	//#CM708351
	//------------------------------------------------------------
	//#CM708352
	/**
	 * Variable which manages statement. 
	 */
	protected Statement p_Statement = null ;

	//#CM708353
	/**
	 * Variable which maintains retrieval result. 
	 */
	protected ResultSet p_ResultSet = null ;

	//#CM708354
	/**
	 * Connection instance for data base connection. <BR>
	 * Do not do the transaction management in this class. 
	 */
	private Connection p_Conn ;

	//#CM708355
	/**
	 * Reference table name
	 */
	private String p_TableName = null ;

	//#CM708356
	// Class variables -----------------------------------------------

	//#CM708357
	// Constructors --------------------------------------------------
	//#CM708358
	/**
	 * constructor comment.
	 *
	 * @param conn Connection
	 * @param tbName String
	 */
	public AbstractDBReportFinder(Connection conn, String tbName)
	{
		setTableName(tbName) ;
		setConnection(conn) ;
	}
	
	//#CM708359
	/**
	 * Variable which maintains whether next method can be called. 
	 */
	protected boolean isNextFlag = false;

	//#CM708360
	// Class method --------------------------------------------------
	//#CM708361
	/**
	 * Return Revision of this class. 
	 * @return Revision character string. 
	 */
	public static String getVersion()
	{
		return "$Id: AbstractDBReportFinder.java,v 1.2 2006/11/15 04:25:36 kamala Exp $" ;
	}

	//#CM708362
	// Public methods ------------------------------------------------
	//#CM708363
	/**
	 * Set <code>Connection</code> for the data base connection. 
	 * @param conn Connection to be set
	 */
	public void setConnection(Connection conn)
	{
		p_Conn = conn ;
	}

	//#CM708364
	/**
	 * Acquire <code>Connection</code> for the data base connection. 
	 * @return <code>Connection</code> being maintained
	 */
	public Connection getConnection()
	{
		return (p_Conn) ;
	}

	//#CM708365
	/**
	 * Set <code>TableName</code> for the database connection
	 * @param tblName Table name to be set
	 */
	public void setTableName(String tblName)
	{
		p_TableName = tblName ;
	}

	//#CM708366
	/**
	 * Acquire <code>TableName</code> for the database connection
	 * @return <code>TableName</code> being maintained
	 */
	public String getTableName()
	{
		return p_TableName ;
	}
	
	//#CM708367
	/**
	 * Generate the statement, and open the cursor. 
	 * @throws ReadWriteException It is notified when abnormality occurs by the connection with the data base. 
	 */
	public void open() throws ReadWriteException
	{
		try
		{
			p_Statement = p_Conn.createStatement(
												ResultSet.TYPE_FORWARD_ONLY, 
												ResultSet.CONCUR_READ_ONLY
											  ) ;
		}
		catch (SQLException e)
		{
			//#CM708368
			//6006002 = Database error occurred.{0}
			RmiMsgLogClient.write( new TraceHandler(6006002, e), p_TableName ) ;
			throw (new ReadWriteException("6006002" + wDelim + Integer.toString(e.getErrorCode()))) ;
		}
	}
	//#CM708369
	/**
	 * The mapping of the result set. 
	 *
	 * @param Acquisition number of retrieval results
	 * @return Entiry array
	 * @throws ReadWriteException Notify the exception generated by the database connection as it is. 
	 * @return Entity[]
	 */
	public Entity[] getEntities(int count) throws ReadWriteException
	{
		Vector entityList = new Vector() ;
		AbstractEntity[] entityArr = null ;
		AbstractEntity tmpEntity = createEntity() ;
		try
		{
			
			//#CM708370
			// Count the number read this time. 
			int readCount = 0;
			//#CM708371
			// Flag whether to close ResultSet. Close after reading the final line. 
			boolean endFlag = true;
			while ( p_ResultSet.next() )
			{			
				for (int i = 1; i <= p_ResultSet.getMetaData().getColumnCount(); i++)
				{
					String colname = p_ResultSet.getMetaData().getColumnName(i) ;
					FieldName field = new FieldName(colname) ;
	
					//#CM708372
					// The class at DateTime might take the millisecond if it is not getTimestamp() and leak it. 
					Object value = p_ResultSet.getObject(i) ;
					if (value instanceof java.util.Date)
					{
						value = p_ResultSet.getTimestamp(i) ;
					}

					tmpEntity.setValue(field, value) ;
				}
				entityList.addElement(tmpEntity) ;
	
				tmpEntity = createEntity() ;
				
				//#CM708373
				// It comes off while when the specified number of cases is read. 
				readCount++;
				if ( count <= readCount )
				{
					endFlag = false;
					break;
				}
			}
			//#CM708374
			// Close after reading the final line. 
			if ( endFlag )
			{
				isNextFlag = false ;
				close();
			}
	
			//#CM708375
			// Each table was cut in Cast to Entity[].
			entityArr = (AbstractEntity[])java.lang.reflect.Array.newInstance(
					tmpEntity.getClass(), entityList.size()) ;
			entityList.copyInto(entityArr) ;

		}
		catch (SQLException e)
		{
			//#CM708376
			// 6006002 = Database error occurred.{0}
			RmiMsgLogClient.write(new TraceHandler(6006002, e), this.getClass().getName()) ;
			//#CM708377
			// Here, throw ReadWriteException with the error message. 
			//#CM708378
			// 6006039 = Failed to search for {0}.
			throw (new ReadWriteException("6006039" + wDelim + p_TableName)) ;
		}
		return entityArr ;
	}

	//#CM708379
	/**
	 * Return whether the next method can be executed. 
	 * @return isNextFlag true: Entity can be acquired by the next method. False:Entity cannot be acquired. 
	 */
	public boolean isNext()
	{
		return isNextFlag;
	}

	protected abstract AbstractEntity createEntity() ;

	//#CM708380
	/**
	 * Close the statement. 
	 * @throws ReadWriteException It is notified when abnormality occurs by the connection with the data base. 
	 */
	public void close() throws ReadWriteException
	{
		try
		{
			if (p_ResultSet != null) { p_ResultSet.close();  p_ResultSet = null; }
			if (p_Statement != null) { p_Statement.close();  p_Statement = null; }
		}
		catch (SQLException e)
		{
			//#CM708381
			// 6006002 = Database error occurred.{0}
			RmiMsgLogClient.write(new TraceHandler(6006002, e), this.getClass().getName());
			throw (new ReadWriteException("6006002" + wDelim + p_TableName));
		}
	}

	//#CM708382
	/**
	 * Retrieve the data base, and acquire it. 
	 * @param key Key for retrieval
	 * @return Retrieval results qty
	 * @throws ReadWriteException Notify the exception generated by the connection with the data base as it is. 
	 */
	public int search(SearchKey key) throws ReadWriteException
	{
		close();
		open();

		Object[] fmtObj = new Object[4] ;
		Object[] cntObj = new Object[4];
		int count = 0;
		ResultSet countret  = null ;
		
		try
		{
			String fmtCountSQL = "SELECT COUNT({0}) COUNT " 
				+ "FROM " + p_TableName + " "
				+ "{1} {2} {3} ";

			String fmtSQL = "SELECT {0} "
				+ "FROM " + p_TableName + " "
				+ "{1} {2} {3}";
//#CM708383
//			 Edit the acquisition condition. 
			if (key.getCollectConditionForCount() != null)
			{
				cntObj[0] = key.getCollectConditionForCount();
			}
			else
			{
				//#CM708384
				// It is assumed to the acquisition condition all item acquisition at the time of a specified doing. 
				cntObj[0] = " * ";
			}
			
			//#CM708385
			// Edit the acquisition condition. 
			if (key.getCollectCondition() != null)
			{
				fmtObj[0] = key.getCollectCondition() ;
			} else {
				//#CM708386
				// It is assumed to the acquisition condition all item acquisition at the time of a specified doing. 
				fmtObj[0] = " * " ;
			}

			//#CM708387
			// Edit the search condition. 
			if (key.getReferenceCondition() != null)
			{
				fmtObj[1] = "WHERE " + key.getReferenceCondition();
				cntObj[1] = "WHERE " + key.getReferenceCondition();
			}

			//#CM708388
			// Edit the consolidating condition. 			
			if (key.getGroupCondition() != null)
			{
				fmtObj[2] = " GROUP BY " + key.getGroupCondition();
				cntObj[2] = " GROUP BY " + key.getGroupCondition();
			}

			//#CM708389
			// Edit the order of reading. 				
			if (key.getSortCondition() != null)
			{
				fmtObj[3] = "ORDER BY " + key.getSortCondition();
				cntObj[3] = "ORDER BY " + key.getSortCondition();
			}

			String sqlcountstring = SimpleFormat.format(fmtCountSQL, cntObj) ;
DEBUG.MSG("HANDLER", p_TableName + " ReportFinder COUNT SQL[" + sqlcountstring + "]") ;
			countret = p_Statement.executeQuery(sqlcountstring);
			while (countret.next())
			{
				count = countret.getInt("COUNT");
			}
			//#CM708390
			//Execute only one retrieval or more. 
			if ( count > 0 )
			{
				String sqlstring = SimpleFormat.format(fmtSQL, fmtObj) ;
DEBUG.MSG("HANDLER", p_TableName + " RportFinder SQL[" + sqlstring + "]") ;
				p_ResultSet = p_Statement.executeQuery(sqlstring);
				isNextFlag = true;
			}
			else
			{
				p_ResultSet = null;
				isNextFlag = false;
			}
		}
		catch (SQLException e)
		{
			//#CM708391
			//6006002 = Database error occurred.{0}
			RmiMsgLogClient.write( new TraceHandler(6006002, e), p_TableName ) ;
			throw (new ReadWriteException("6006002" + wDelim + p_TableName)) ;
		}
		return count;

	}

}
