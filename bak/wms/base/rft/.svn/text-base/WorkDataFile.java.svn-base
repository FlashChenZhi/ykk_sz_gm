// $Id: WorkDataFile.java,v 1.2 2006/11/14 06:09:22 suresh Exp $
package jp.co.daifuku.wms.base.rft;

import java.io.File;
import java.io.IOException;
import java.sql.Connection;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import jp.co.daifuku.common.DataExistsException;
import jp.co.daifuku.common.InvalidDefineException;
import jp.co.daifuku.common.InvalidStatusException;
import jp.co.daifuku.common.NoPrimaryException;
import jp.co.daifuku.common.NotFoundException;
import jp.co.daifuku.common.ReadWriteException;
import jp.co.daifuku.wms.base.common.Entity;
import jp.co.daifuku.wms.base.common.WmsParam;
import jp.co.daifuku.wms.base.communication.rft.PackageManager;
import jp.co.daifuku.wms.base.dbhandler.WorkingDataAlterKey;
import jp.co.daifuku.wms.base.dbhandler.WorkingDataHandler;
import jp.co.daifuku.wms.base.dbhandler.WorkingDataSearchKey;
import jp.co.daifuku.wms.base.entity.WorkingData;

//#CM702586
/*
 * Copyright 2005 DAIFUKU Co.,Ltd. All Rights Reserved.
 *
 * This software is the proprietary information of DAIFUKU Co.,Ltd.
 * Use is subject to license terms.
 */

//#CM702587
/**
 * Super-class of work Data file sent and received by RFT communication. <BR>
 * Use the subclass of each ID to operate an actual file. 
 * 
 * @version $Revision: 1.2 $, $Date: 2006/11/14 06:09:22 $
 * @author  $Author: suresh $
 */
public abstract class WorkDataFile extends IdDataFile
{

	//#CM702588
	// Class fields --------------------------------------------------
	
	//#CM702589
	// Class variables -----------------------------------------------
	//#CM702590
	/**
	 * Path name of Working data file
	 */
	protected String workingDataFileName = null;
	
	
	//#CM702591
	// Class method --------------------------------------------------
	//#CM702592
	/**
	 * Return the version of this class. 
	 * @return Version and date
	 */
	public static String getVersion()
	{
		return "$Revision: 1.2 $,$Date: 2006/11/14 06:09:22 $";
	}

	//#CM702593
	/**
	 * Acquire Working data from Working data preservation information. <BR>
	 * Acquire correspondence Data from Working data preservation information in Row No ascending order contingent 
	 * on title machine No which acquires it in the parameter. <BR>
	 * Make the RECV folder work file with File Name of acquired Working data. <BR>
	 * Acquire ID from made File Name and generate the file operation object. 
	 * 
	 * @param rftNo	RFT machine No
	 * @param conn		DB Connection
	 * @return			Generated Data file operation instance
	 * @throws IOException It is notified when Error is generated by inputting and outputting the file. 
	 * @throws IllegalAccessException It is notified when failing in the generation of the instance. 
	 * @throws ReadWriteException It is notified when failing in the access of DB. 
	 * @throws NotFoundException It is notified when object Data does not exist. 
	 */
	public static WorkDataFile loadWorkingDataFile(String rftNo, Connection conn) throws IllegalAccessException, ReadWriteException, IOException, NotFoundException
	{
		//#CM702594
		// Acquire the identification number of the Working data file. 
		String id = getWorkingDataId(rftNo, conn);
		if (id == null)
		{
			return null;
		}
		
		WorkDataFile workDataFile =
		    (WorkDataFile) PackageManager.getObject("Id" + id + "DataFile");
		//#CM702595
		// Make the Working data file. 
		String filename = restoreDataFile(rftNo, false, conn);
		workDataFile.setFileName(filename);

		return workDataFile;
	}
	
	
	//#CM702596
	// Constructors --------------------------------------------------
	//#CM702597
	/**
	 * Generate the instance. 
	 */
	public WorkDataFile()
	{
		super();
	}

	//#CM702598
	/**
	 * Generate the instance. 
	 * @param	len		Length of 1 line
	 */
	public WorkDataFile(int length)
	{
		super(length);
	}

	//#CM702599
	/**
	 * Generate the instance. 
	 * 
	 * @param	filename	DataFile Name (Path is unnecessary. ) 
	 */
	public WorkDataFile(String filename)
	{
		setFileName(filename);
	}

	//#CM702600
	// Public methods ------------------------------------------------
	//#CM702601
	/**
	 * Set it after converting specified File Name into the path name. 
	 * 
	 * @param	filename	DataFile Name (Path is unnecessary. ) 
	 */
	public void setFileName(String filename)
	{
		super.setFileName(filename);
		
		//#CM702602
		// Generate the path name of Working data File. 
		workingDataFileName = wFileName.replaceAll("\\\\send\\\\", "\\\\recv\\\\");
	}

	//#CM702603
	/**
	 * Acquire the Data file. 
	 * 
	 * @return	DataFile Name
	 */
	public String getWorkingDataFile()
	{
	    return workingDataFileName;
	}

	//#CM702604
	/**
	 * Update the Data item of Working data preservation information. <BR>
	 * Retrieve Working data preservation information contingent on RFT machine No and Row No. 
	 * Update the Data item of correspondence Data in work Data of the argument. 
	 * 
	 * @param workingData	Preserved work Data
	 * @param rftNo RFT machine No
	 * @param fileName Work File Name
	 * @param lineNo Row No
	 * @param conn Connection object with data base
	 * @throws ReadWriteException It is notified when failing in the access of DB. 
	 * @throws InvalidDefineException It is notified for an illegal parameter. 
	 * @throws NotFoundException It is notified when update object Data does not exist. 
	 * @throws InvalidStatusException It is notified when the specified line - number and the line - number in Data are different. 
	 * @throws NoPrimaryException It is notified when Error is generated by the unique key restriction of DB. 
	 */
	public static void updateWorkingData(byte[] workingData, String rftNo,  String fileName, int lineNo, Connection conn) throws ReadWriteException, NotFoundException, InvalidDefineException, InvalidStatusException, NoPrimaryException
	{
		//#CM702605
		// Remove the passing part from File Name. 
		File updatefile = new File(fileName);
		fileName = updatefile.getName();

		//#CM702606
		// Acquire Data of Row No specified from Working data preservation information. 
		WorkingDataSearchKey skey = new WorkingDataSearchKey();
		WorkingDataHandler aHandler = new WorkingDataHandler(conn);
		//#CM702607
		//-----------
		//#CM702608
		// Search condition
		//#CM702609
		//-----------
		skey.setRftNo(rftNo);
		skey.setLineNo(lineNo);
		skey.setFileName(fileName);
		WorkingData wd = (WorkingData)aHandler.findPrimary(skey);
		
		if (wd == null)
		{
			//#CM702610
			// Error when Working data is not found
			throw new NotFoundException();
		}
		//#CM702611
		// Acquire Row No from Content Data of acquired Working data preservation information. 
		int dataLineNo;
		
		try
		{
			dataLineNo = Integer.parseInt(wd.getContents().substring(OFF_LINE_NO, LEN_LANE_NO).trim());
		}
		catch (NumberFormatException e)
		{
			//#CM702612
			// Error when acquired Row No is not numerical value
			throw new InvalidStatusException();
		}

		if (lineNo != dataLineNo)
		{
			//#CM702613
			// Index Error
			throw new InvalidStatusException();
		}
		WorkingDataAlterKey akey = new WorkingDataAlterKey();
		//#CM702614
		//------------
		//#CM702615
		// Update condition
		//#CM702616
		//------------
		akey.setRftNo(rftNo);
		akey.setLineNo(lineNo);
		akey.setFileName(fileName);
		//#CM702617
		//------------
		//#CM702618
		// Content of update
		//#CM702619
		//------------
		akey.updateContents(new String(workingData));
		
		aHandler.modify(akey);
	}

	//#CM702620
	/**
	 * Make Working data for Working data preservation information. <BR>
	 * <BR>
	 * Information on the same content as the work file made is inserted and Re Code is inserted in Working data preservation information 1Data. <BR>
	 * Overwrite when same RFT No. and information on Row No have already existed. <BR>
	 * <BR>
	 * 1.Retrieve Working data preservation information. <BR>
	 * [Search condition]
	 * <UL><LI>RFT machine No : Acquisition from parameter</LI>
	 *     <LI>Row No : Acquisition from parameter</LI>
	 * </UL>
	 * 2.Update when same information exists, and do New making when not is. <BR>
	 * [Update and Making condition]
	 * <UL><LI>RFT machine No (In case of making) </LI>
	 *     <LI>File Name(Remove when you contain the Path part. )</LI>
	 *     <LI>Row No</LI>
	 *     <LI>Content Data(1Data):Reading 1Data takes out the made work file. </LI>
	 * </UL>
	 * 
	 * @param rftNo RFT machine No
	 * @param fileName Work File Name
	 * @param fileRecordNumber Work file qty
	 * @param conn Database Connection
	 * @throws ReadWriteException It is notified when failing in the access of DB. 
	 * @throws NotFoundException It is notified when update object Data does not exist. 
	 * @throws InvalidDefineException It is notified for an illegal parameter. 
	 * @throws IllegalAccessException It is notified when failing in the generation of the instance. 
	 * @throws IOException It is notified when failing in the I/O of the file. 
	 */
	public void saveWorkingDataFile(String rftNo, String fileName, int fileRecordNumber, Connection conn) 
		throws ReadWriteException, NotFoundException, InvalidDefineException, IllegalAccessException, IOException
	{		
		String id = "";
		Matcher m = Pattern.compile("ID(\\d\\d\\d\\d).txt").matcher(fileName);
		if (m.find())
		{
			id = m.group(1);
		}
		//#CM702621
		// Generation of instance of work file
		WorkDataFile workDataFile =
		    (WorkDataFile) PackageManager.getObject("Id"+ id + "DataFile");
		workDataFile.setFileName(fileName);
		
		//#CM702622
		// Remove the passing part of File Name. 
		File file = new File(fileName);
		String registFileName = file.getName();
		try
		{			
			WorkingDataHandler wHandler = new WorkingDataHandler(conn);
			//#CM702623
			// Open the made work file. 
			workDataFile.openReadOnly();
			int i = 0;
			for(workDataFile.next(); i < fileRecordNumber; workDataFile.next())
			{	
				WorkingDataAlterKey akey = new WorkingDataAlterKey();
				akey.setRftNo(rftNo);
				akey.setLineNo(i);
				akey.updateFileName(registFileName);
				akey.updateContents(workDataFile.getContents());

				WorkingDataSearchKey skey = new WorkingDataSearchKey();
				skey.setRftNo(rftNo);
				skey.setFileName(registFileName);
				skey.setLineNo(i);
				WorkingData[] workingArr= (WorkingData[])wHandler.find(skey);
				if (workingArr.length > 0)
				{
					wHandler.modify(akey);
				}
				else
				{
					try
					{
						WorkingData workdata = new WorkingData();
						workdata.setRftNo(rftNo);
						workdata.setFileName(registFileName);
						workdata.setLineNo(i);
						workdata.setContents(workDataFile.getContents());
						wHandler.create(workdata);
					}
					catch (DataExistsException e)
					{
						wHandler.modify(akey);
					}
				}
				i++;
			}
		}
		finally
		{
			workDataFile.closeReadOnly();
		}
		
	}

	//#CM702624
	/**
	 * Read Data from the FTPData file, put in Entity array of an appropriate type, and return it. <BR>
	 * The type of an actual array is different according to ID. 
	 * @return		Data read from file(Entity array)
	 * @throws IOException It is notified when failing in the I/O of the file. 
	 * @throws InvalidStatusException Notify when there is no adjustment in a set value of Data. 
	 */
    public Entity[] getCompletionData() throws IOException,
            InvalidStatusException
    {
        return getWorkDataFromFile(wFileName);
    }
    
	//#CM702625
	/**
	 * Read Data from the Working data file, put in Entity array of an appropriate type, and return it. <BR>
	 * The type of an actual array is different according to ID. 
	 * @return		Data read from file(Entity array)
	 * @throws IOException It is notified when failing in the I/O of the file. 
	 * @throws InvalidStatusException Notify when there is no adjustment in a set value of Data. 
	 */
    public Entity[] getWorkingData() throws IOException,
            InvalidStatusException
    {
        return getWorkDataFromFile(workingDataFileName);
    }

	//#CM702626
	/**
	 * Read Data from the specified file, put in Entity array of an appropriate type, and return it. <BR>
	 * The type of an actual array is different according to ID. 
	 * @param filename Work File Name
	 * @return		Data read from file(Entity array)
	 * @throws IOException It is notified when failing in the I/O of the file. 
	 * @throws InvalidStatusException Notify when there is no adjustment in a set value of Data. 
	 */
    abstract public Entity[] getWorkDataFromFile(String filename)
    	throws IOException, InvalidStatusException;

	public void setRequestInfo(jp.co.daifuku.wms.base.entity.WorkingInformation[] workinfo, IdMessage request)
	{
	    ;
	}
	
	//#CM702627
	// Package methods -----------------------------------------------

	//#CM702628
	// Protected methods ---------------------------------------------
	//#CM702629
	/**
	 * Generate the file with work Data acquired from Working data preservation information. 
	 * Do the processing Restored to send or the recv folder. 
	 *
	 * @param rftNo	RFT machine No
	 * @param isSend	Flag whether to Restore it to send folder
	 * @param conn		DB Connection
	 * @return File Name
	 * @throws IOException It is notified when failing in the I/O of the file. 
	 * @throws ReadWriteException It is notified when failing in the access of DB. 
	 * @throws IllegalAccessException It is notified when failing in the generation of the instance. 
	 * @throws NotFoundException It is notified when object Data does not exist. 
	 */
	public static String restoreDataFile(String rftNo, boolean isSend, Connection conn) throws IOException, ReadWriteException, IllegalAccessException, NotFoundException
	{   
		//#CM702630
		// Acquire File Name from Working data preservation information. 
		WorkingDataSearchKey wkey = new WorkingDataSearchKey();
		WorkingDataHandler wHandler = new WorkingDataHandler(conn);
		
		//#CM702631
		//-----------
		//#CM702632
		// Search condition
		//#CM702633
		//-----------
		wkey.setRftNo(rftNo);
		wkey.setLineNoOrder(1, true);
		
		WorkingData[] workdata = (WorkingData[])wHandler.find(wkey);
		
		if (workdata == null || workdata.length == 0)
		{
			throw new NotFoundException();
		}
		String fileName = workdata[0].getFileName();
		
		//#CM702634
		// Working data File Name ID is acquired. 
		String id = IdMessage.getWorkingDataId(rftNo, conn);
		//#CM702635
		// Generation of instance of work file
		WorkDataFile workDataFile =
		    (WorkDataFile) PackageManager.getObject("Id"+ id + "DataFile");
		
		String resultFileName;
		if (isSend)
		{
			resultFileName = WmsParam.RFTSEND;
		}
		else
		{
			resultFileName = WmsParam.RFTRECV;
		}

		fileName =  resultFileName
					+ rftNo
					+ File.separatorChar
					+ fileName;
		
		workDataFile.setFileName(fileName);
		try
		{
			//#CM702636
			// Make the work file for the recv folder. 
			workDataFile.openWritable();
			for (int i = 0; i < workdata.length; i ++)
			{
				String contents = workdata[i].getContents();
				workDataFile.setContents(contents);
				workDataFile.writeln();
			}
		}
		finally
		{
			if (workDataFile.writer != null)
			{
				workDataFile.closeWritable();				
			}
		}
		
		return fileName;

	}

	//#CM702637
	/**
	 * Acquire Row No filing Data from the Data buffer. 
	 * @return		Row No filing Data
	 */
	public int getLineNo()
	{
		return getIntColumn(OFF_LINE_NO, LEN_LINE_NO);
	}
	
	//#CM702638
	/**
	 * Set Row No in the Data buffer. 
	 * @param	lineNo	Row No filing Data
	 */
	public void setLineNo(int lineNo)
	{
		setIntColumn(lineNo, OFF_LINE_NO, LEN_LINE_NO);
	}
	
	//#CM702639
	/**
	 * Set Working data (1 Data line) in the Data buffer. 
	 * @param contents Working data (1 Data line) 
	 */
	public void setContents(String contents)
	{
		setColumn(contents, OFF_LINE_NO, lineLength);
	}
	
	//#CM702640
	/**
	 * Acquire Working data (1 Data line) from the Data buffer. 
	 * @return Working data (1 Data line) 
	 */
	public String getContents()
	{
		return getRawColumn(OFF_LINE_NO, lineLength);
	}


	//#CM702641
	// Private methods -----------------------------------------------
}
//#CM702642
//end of class
